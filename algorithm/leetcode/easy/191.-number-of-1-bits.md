# 191. Number of 1 Bits

## [Problem](https://leetcode.com/problems/number-of-1-bits/)

### Description

Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming\_weight)).

**Note:**

* Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
* In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's\_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.

**Example 1:**

```
Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
```

**Example 2:**

```
Input: n = 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
```

**Example 3:**

```
Input: n = 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
```

**Constraints:**

* The input must be a **binary string** of length `32`.

**Follow up:**&#x20;

* If this function is called many times, how would you optimize it?

### 문제 해석

> TL;DR
>
> unsigned integer로 표현된 수에서 `1`의 개수를 구하라

unsigned integer를 받아서 가지고 있는 `1` 비트의 개수를 반환하라 (hamming weight라고 알려져 있다)

노트:

* Java 같은 몇몇 언어에서는 unsigned integer 타입이 존재하지 않는다. 이런 경우 입력은 signed integer 타입으로 지원된다. 정수 내부의 이진 표현이 동일하기 때문에 signed 또는 unsigned 여부가 구현에 영향을 미치지는 않는다.
* Java 컴파일러는 signed integer를 2의 보수의 형태로 표현한다. 그러므로 `3`의 경우는 signed integer에서는 `-3`으로 표현한다.

## Solution

### Solution 1

#### 풀이

Python에서 정수를 2진수 문자열로 변경해주는 `bin` 메서드를 사용해서 푼다.

`bin` 메서드가 반환하는 문자열의 최대 길이는 `32`, 변환된 문자열에서 `'1'` 의 개수를 `count` 메서드를 활용해서 측정한다.

길이가 `32`인 문자열에 대한 `count` 메서드이므로 해당 풀이의 시간 복잡도는 `O(1)`이 된다.

#### 소스 코드 dddfd

dfdfed

```python
```
